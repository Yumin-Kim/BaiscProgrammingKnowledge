# 5장 
## CPU 스케줄링
*  정의 : 다중 프로그램 운영체제의 기본이며 운영체제는 CPU를 프로세스간에 교환함으로서 컴퓨터를 생산적으로 만든다.거의 모든 컴퓨터 자원들은 사용되기 전에 스케줄된다.
* 프로세스의 시작은 CPU Burst로 시작된다.그후 I/O Burst가 발생한다.비교적 CPU Burst의 시간이 비교적 짧고 I/O Burst 시간이 긴 편이다.
* Burst는 어떤 생각 , 일을 집중적 또는 연속적으로 발생하는것을 의미한다.
## 스케줄링 전반적인 요소
* 선점(Preemptive) 방식과 비선점(Non-Preemptive) 방식으로 나뉜다. 선점 스케줄링은 운영체제가 강제로 프로세스의 사용권을 통제하는 방식이고, 비선점 스케줄링은 프로세스가 스스로 다음 프로세스에게 자리를 넘겨주는 방식이다. 즉, 선점 스케줄링 방식에서는 CPU에 프로세스가 할당되어 있을 때도 운영체제가 개입해 다른 프로세스에게 CPU를 할당할 수 있다.
* CPU스케줄링 결정의 네가지 상황
    1. 한 프로세스가 실행 상태에서 대기 상태로 전환될때(I/O 요청이나 자식 프로세스가 종료되기를 기다리기 위해 wait() 호출 할때)
    2. 프로세스가 실행 상태에서 준비 완료 상태로 전환될 때(인터럽트 발생)
    3. 프로세스가 대기 상태에서 준비 완료로 전환될 때(I/O의 종료시)
    4. 프로세스가 종료될때
    * 1,4 과 같은 경우 비선점방식을 나머지 경우는 선점 방식을 사용한다.
* 선점 스케줄리의 경우 불편한점
    1. 데이터가 다수의 프로세스에 의해 공유 될때 경쟁 조건을 초래 >> 데이터의 일관성에 문제가 발생 할 수 있다.
    2. 운영체제 커널 설계에 영향을 미침 >> 시스템 콜을 처리하는 동안 커널은 파일 갱신과 같은 중요한 일을 하는중 한 프로세스가 선점 되어 커널은 동일한 구조를 읽거나 변경할 수 있어 혼란을 야기한다.
* 비선점 커널은 문맥 교환을 하기 전에 시스템 콜이 완료되거나 입출력 완료를 기다리며 프로세스가 봉쇄 되기를 기다린다.
* 디스패처 
    * 디스패처는 CPU 코어의 제어를 CPU 스케줄러가 선택한 프로세스에 주는 모듈
    * 디스패처의 작업 
        1. 한 프로세스에서 다른 프로세스로 문맥을 교환하는 일
        2. 사용자 모드로 전환하는 일
        3. 프로그램을 다시 시작하기 위해서 사용자 프로그램의 적절한 위치로 이동 
    * 디스패처는 모든 프로세스의 문맥 교환 시 호출되고 디스패처가 하나의 프로세스를 정지하고 다른 프로세스의 수행을 시작하는데까지 소요되는 시간을 디스패치 지연이라고 한다.
## 스케줄링 기준 (scheduling criteria)
* CPU 이용률 : CPU를 최대한 바쁘게 유지하며 (MAX)
* 처리량 : CPU가 프로세스를 수행하느라고 바쁘다면 작업이 진행되고 있는것 , 작업량 측정의 한 방법은 단위 시간당 완료된 프로세스의 개수 의미 
* 총 처리시간 : 프로세스를 실행하는데 소요된 시간(총처리 시간은 주비 큐에서 대기한시간 ,CPU에서 실행하는 시간 , 그리고 I/O 시간을 합한 시간)
* 대기 시간 : 준비 큐에서 대기한면서 보낸 시간의 합
* 응답 시간 : 하나의 요구 조건에 따라서 첫 번째 응답이 나올때까지의 시간이다.
## 스케줄링의 알고리즘 
1. FCFS (First-Come, First-Served) - **비선점 스케줄링 방식**
    * 먼저 들어온 프로세스를 먼저 프로세서에 할당하는 방식이다.
    * Queue의 FIFO(First-In First-Out)와 동일하다
    * 프로세스 처리 순서에 따라 성능이 크게 달라질 수 있다
    * 행 시간이 큰 프로세스가 먼저 들어오면 그 뒤에 들어온 프로세스들이 불필요하게 오랜 시간을 기다리게 되는 호위 효과(Convoy effect)가 발생한다.
2. SJF (Shortest Job First) - **비선점 스케줄링 방식**
    * 프로세스의 수행 시간이 짧은 순서에 따라 프로세서에 할당한다.
    * FCFS의 호위 효과를 해결 할 수 있다.
    * 최적 알고리즘이지만 수행 시간(Burst Time)을 정확히 알 수 없다. (앞서 처리한 프로세스들의 기록을 보고 추측한다. >> 지수 평균 예측 방법)
    * 버스트 시간이 큰 프로세스 계속 뒤로 밀려나는 기아가 발생한다.
    * **SRF (Shortest Remaining Time First)** -- **선점 스케줄링 방식**
        * 프로세스의 남은 수행 시간이 짧은 순서에 따라 프로세서에 할당한다.
        * SJF 에서 빌생하는 기아 문제를 해경할 수 있다.
        * 수행 중 다른 프로세스보다 남은 수행 시간이 적어지면 운영체제가 개입해 자리를 바꾸는 방식(도착 시간 고려)
3. RR(Round Robin) - **선점 스케줄링 방식**
    * 일정 시간 할당량 단위로 여러 프로세스를 번갈아가며 프로세서에 할당한다.
    * 시스템의 time-sharing과 같은 방식이다.
    * 응답성 높다.
    * 주로 우선순위 스케줄링과 결합해 프로세스의 시간 할당량(time quantum)을 조절하는 방식으로 활동한다.
    * 시간 할당량이 문맥 교환 시간과 비교해 더 클것을 원하고 하지만 너무 커서도 안된다 이부분을 고려하여 CPU Burst 80%는 시간 할당량보다 짧야한다.
    * 시간 할당량에 따라 운영체제가 계속 개입하는 선점 스케줄링 방식
4. Priority Scheduling - **선점, 비선점 모두 가능**
    * 특정 기준으로 프로세스에게 우선순위를 부여해 우선순위에 따라 프로세서에 할당한다.
    * 우선순위 스케줄링 알고리즘의 주요 문제는 무한 봉쇄(indefinite blocking), 기아 상태(starvation)
    * 해결 방안으로는 프로세스를 에이징(Aging)해서 오래 대기한 프로세스의 우선순위를 높이는 방식으로 사용된다.
    * SRF의 경우 남은 수행 시간을 기준으로 우선순위를 부여한다고 할 수 있다.
5. Multilevel Queue Scheduling
    * 우선 순위 스케줄링이 라운드 로빈과 결합한 경우에도 효과적이다.
    * 포그라운드(foreground, 대화형) 프로세스들과 백그라운드(background, 일괄처리) 프로세스들을 구분합니다. 
    * 프로세스간 각 큐를 별도로 가지고 있다.
        1. 시스템 프로세스
        2. 대화형 프로세스
        3. 대화형 편집 프로세스
        4. 일괄처리 프로세스
        5. 학생 프로세스
    * Ready Queue를 다수의 별도의 큐로 분류합니다 >>> 일반적으로 프로세스들은 메모리 크기, 프로세스의 우선순위 혹은 프로세스 유형과 같은 프로세스의 특성에 따라 한 개의 큐에 영구적으로 할당돠며 각기 다른 스케줄링 알고리즘을 가지고 있다.
    * 포그라운드는 RR을 백그라운드는 FCFS를 스케줄링 알고리즘을 가지고 있다 >> 큐간에는 우선 순위 선점형 스케줄링 알고리즘이 구현되어 있다. 
    * 대화형 프로세스가 준비 큐에 들어가면 배치 프로세스는 선점 될것이다 >> 기아 현상 발생할 수 있다.
    * 포그라운드 와 백그라운드 프로세스를 위해 별도의 큐가 있을경우 프로세스들은 한큐에서 다른큐로 이동하지못하며 이유는 프로세스는 특성이 바뀌지 않기 때문이며 스케줄링 오버헤드가 장점이 있으나 융통성이 적다.
6. Multilevel Feedback Queue Scheduling
    * 프로세스들이 시스템 진입 시에 영구적으로 하나의 큐에 할당됩니다.
    * 프로세스가 큐들 사이를 이돌하는것을 허용하며 프로세스들은 CPU Burst성격에 따라서 구분합니다.
    * CPU의 사용시간이 많으면 우선순위가 낮은 큐로 이동한다. 입출력 중심의 프로세스와 대화형 프로세스들을 높은 순위의 큐로 넣는다.
    * 낮은 순위에 있는 프로세스가 너무 오래 대기하게 되면 높은 우선 순위의 큐로 이동한다. 이러한 노화 형태는 기아 상태를 예방합니다.
    * 매개 변수 
        1. 큐의 개수
        2. 각 큐를 위한 스케줄링 알고리즘
        3. 한 프로세스를 높은 우선순위 큐로 올려주는 시기를 결정하는 방법
        4. 한 프로세스를 낮은 우선순위 큐로 강등시키는 시기를 결정하는 방법
        5. 프로세스가 서비스를 필요로 할 때 프로세스가 들어갈 큐로 결정하는 방법
# 6장 프로세스 동기화
## 등장 배경
* 프로세스는 명령엉가 실행될때 어느 지점에서나 인터럽트 되고 , 처리 코어는 다른 프로세스의 명령어를 실행하도록 힐당한다. 또한 병렬 실행 즉 다른 프로세스에 속한 두개의 명령어 흐름이 한순간에 다른 처리 코어에서 동시에 실행되는 방식을 소개한다.     
병행또는 병렬 실행될때 여러 프로세스가 공유하는 데이터의 무결성에 어떤 문제를 일으키는지에 대해 설명 하고 있다.     
동시에 여러개의 프로세스가 동일한 자료를 접근하여 조작하고 그 실행 결과가 접근 이 발행한 특정 순서에 의존하는 상황인 **경쟁 상황(Race Condition)**이라고 한다. 위와 같은 상황으로 부터 보호하기 위해 한순간에 하나의 프로세스만이 변수 Counter르 조작하고록 보장 해야한다. 이러한 보장을 위해 어떤 형태로든 프로세스들이 동기화 되도록 할 필요가 있다.      
운영체제의 여러부분에서 자원을 조작 하기 때문에 위와 같은 상황은 빈번하게 발생한다. 다중 코어 시스템의 성장과 더불어 다중 스레드 응용의 개발에 관한 관심이 증가하고 이러한 다중 스레드 응용에서는 자원을 공유할 가능성이 매우 높은 여러 스레드가 서로 다른 처리코어에서 병렬로 실행된다.     
서로간에 영향을 주지 않기를 원하며 이문제는 협력하느 프로세스들간의 프로세스 동기화 조정에 할애된다.    
## 임계 구역 문제(The Critical Section Problem)
* 프로세스 동기화 에 관한 논의는 임계 구역 문제하고 불리는 문제로부터 시작한다.    
    n개의 프로세스 {p0 ~ pn-1}이 있는 시스템을 고려해보면 각 프로세스는 임계 구역이라는 부르는 코드 부분을 포함하고 있고 , 그 안에서는 다른 프로세스와 공유하는 변수를 변경하거나 테이블을 갱신하거나 파일을 관련 작업을 수행한다.     
    **이 시스템의 중요한 특징은 "한 프로세스가 자신의 임계 구역에서 수행하는 동안에는 다른 프로세스들은 그들의 임계구역에 들어 갈 수 없다"!!**    
    임계구역 문제는 프로세스들이 협력할 때 사용할 수 있는 프로토콜을 설계하는 것이며 각 프로세스는 자신의 임계 구역으로 진입허가를 요청해야한다.    
    이러한 요청을 구현하는 코드 부분을 **진입 구역** 이라고 한다. 임계 구역뒤에는 퇴출 구역이 따라온다. 코드의 나머지 부분들은 총칭하여 **나머지 구역**이라고 한다.      
    임계 구역 문제에 대한 해결안은 다음의 세가지 요구 조건 존재   
    1. 상호 배제(mutual exculsion) : 프로세슷 PI가 자신의 임계 구역애서 실행된다면 다른 프로세스들은 그들 자신의 임계구역에서 실행될 수 있다.
    2. 진행(progress) : 자기 임계구역에서 실행된느 프로세스가 없고 그리고 그들 자신의 임계 구역으로 진입하려고 하는 프로세스들이 있다면 나머지 구역에서 실행 중이지 않은 프로세스들만 다음에 누가 그 임계 구역으로 진입 할 수 있는지를 결점하는데 참여할 수 있으며 이선택은 무한정 연기 될 수 없다.     
    3. 한정된 대기(bounded waiting) : 프로세스가 자기의 입계 구역에 진입하려는 요청을 한 후분터 그 요청이 허용될때까지 다른 프로세스들이 그들 자신의 임계 구역에 진입하도록 허용되는 횟수에 한계가 있어야한다.
* 운영체제 내에서 임계 구역을 다루기 위해 선점형 , 비선점형 커널의 두가지 일반적인 접근법이 사용된다. 선점형 커널은 프로세슷가 커널모드에서 수행되는 동안 선점되는 것을 허용한다. 비선점형 커널은 커널 모드에서 수행는 프로세스의 선점을 허용하지 않고 커널 모드 프로세스는 커널을 빠져나갈때 까지 또는 봉쇄 될때까지 또는 자발적으로 CPU의 제어를 양보할 때 까지 계속 수행된다.    
* 비선점형 커널은 한순간에 커널안에서는 실행 중 인 프로세스는 하나 밖에 없기 때문에 커널 자료 구조에 대한 경쟁 조건을 염려할 필요없다    
선점형 커널은 공유된느 커널 자료구조에서 경쟁 조건이 발생하지 않는 다는 것을 고려하여 신중하게 설계 되어야한다.**커널 모드 프로세스가 대기중인 프로세스에게 처리기를 양도하기전에 오랫동안 실행할 위험이 적기 때문에 선점형 커널은 응답이 더 민첩할 수 있다**
## 피터슨 해결안
* 고전적인 소프트웨어 기반 해결책이며 현대 컴퓨터 구조에서 잘맞다고는 할 수 없지만 상호 배제, 진행 , 한정된 대기의 요구조건을 만족 할 수 있다.     
피터슨 해결안은 임계 구역과 나머지 구역을 번갈아 가며 실행하는 두개의 프로세스가 한정된다.두 프로세스가 두개의 데이터를 공유하도록 하여 해결한다.     
* PerterSon Solution으로 임계 영역 문제를 해결 할 수 있다.
임계 영역에건 프로세스가 작업중인지 저장하는 변수 flag와 critical sectiond에 진입하고자 하는 프로세스를 가리키는 변수 turn을 만들어 어떤 프로세스가 임계 영역에 진입하면 flag를 lock하고 나오면 , unlock하는 방식으로 임계 영역 문제를 해결한다.
```
do
{
	flag[i] = true;
	turn = j;
	while(flag[j] && turn == j )
//Critical Section 
flag[i] = false;
//Remainder Section
}
while(true);
```
* 올바르게 동작하는것을 증명
    1. 상호 배제가 제대로 지켜진다는 사실
    2. 진행에 대한 요구조건을 만족한다는 사실
    3. 대기 시간이 한없이 길어지지않느다느 사실
## 하드웨어로 동기화문제해결
 * 하드웨어 명령어 
    * test_and set() : 이 명령어는 하드웨어애서 지원해주는 명령어로 원자적으로 실행된다.
    * compare_and_swap() : 이 명령어 또한 test_and_set과 같이 동작한다. 하지만 두 워드의 내용 교환에 기반을 두고 있다.
        * 임의의 순서로 순차적으로 실행된다.
        * 인터럽트 당하지 않고 한 프로세스만 실행가능하게 해준다. >> 하지만 한정적 대기 시간를 해결하지 못한다.
        * 원자적인 행위는 수행 도중 중단 될 수 없는 하나의 동작 단위를 일컫는 말이다.
## Muutex Lock
* 임계 구역 문제에 대한 하드웨어 기반 해결책은 복잡하며 응용 프로그래머는 사용할 수 없다.대신 가장 간단한 방법으로는 Mutext락 Library를 사용하는것이다.    
우리는 임계 구역을 보호하고 따라서 경쟁 조건을 방지하기 위해 mutex 락을 사용한다.     
즉 프로세스는 임계 구역에 들어가기전에 반드시 락을 획득해야 하고 나올떄 락을 반환 해야한다. mutex락은 available이라는 불린 변수 가집니다. 이 변수 값의 락의 가용 여부를 표시합니다. 락이 가용하면 acquire()호출은 성공하고 락은 곧 사용 불가 상태가 됩니다. 사용 불가 상태의 락은 획득하려고 시도하는 프로세스는 락이 반환될때까지 봉쇄한다.
* 구현 방식의 단점은 바쁜대기를 해야한다는 점입니다. 프로세스 임계구역에 있는 동안 임계 구역에 들어가기 원하는 다른 프ㄴ로세스들은 acquire() 함수를 호출하는 반복문을 계속 실행해야한다. 사실 이러한 유형의 mutex락은 락이 가용해지기를 기다리면서 프로세스가 계속 회전을 하고 있기 때문에 spinlock이라고 부른다.       
* Mutex Lock은 여러 스레드가 공통 리소스에 접근하는 것을 제어하는 기법으로 lock이 하나만 존재할 수 있는 locking 매커니즘을 따른다.이미 하나의 스레드가 critical section에서 작업중인 lock 상태에서 다른 스레드들은 critical section에 진입할 수 없도록 한다.
* 주 API 설명
    * acquire(): 락을 획득하는 함수
    * release(): 락을 변환하는 함수
**[mutex 사용할 라이브러리](https://modoocode.com/270)**
## 세미포(Semphores)
* 유래 : 기찻길에서 깃발 표식으로 파란색이 걸려있으면 섰다가 지나가도 되고 빨간색이 걸려있으면 섰다가 지나가면 지나가게끔 하는 용도로 깃발을 사용하는데 깃발을 **semphore**라고한다.     
기찻길중 겹치는 부분을 critical section이라고 하며 실질적으로 semaphrore는 shared Data의 개수를 의미한다.     
* 세마포어(Semphore)는 여러 개의 프로세스나 스레드가 critical section에 진입 할 수 있는 locking 매커니즘이다. 세마포어는 카운터를 이용해 동시에 리소스에 접근 할 수 있는 프로세스를 제한한다. 물론 한 프로세스가 값을 변경할 때 다른 프로세스가 변경할 떼 다른 프로세스가 동시에 값을 변경하지는 못한다.
* **공유 자원의 개수를 나타내는 변수이다!!**
* 세미포어의 카운터가 한 개인 경우 바이너리 세마포어(Binary Semphore)두개의 이상인 카운팅 세마포어(Counting semphore)라고 한다. 바이너리 세마포어는 사실상 mutex와 같다.
* 주 API 설명
    * semphore S : int value , struct process * list로 구성되어 있다. 
    * wait() : lock이 되어있는지 검사하는 함수 없다면 등록하는 함수
    * signal() : 연산을 증가하는 함수 이며 숫자가 증가함에 따라 lock(열쇠)를 반납한다고 비유할 수 있다.
* 세마포나 Mutex에서 바쁜대기 해결 방안
    * 세마포에서는 바쁜대기를 해결하기 위해서 대기큐를 사용한다. 대기 큐에 삽입된 프로세스는 대기 상태로 변환한다. >> no Busy Waiting 이라고 한다.
### 참고 자료
* **[참고 자료_1](https://parksb.github.io/article/10.html)**
* **[참고 자료_2](https://ggodong.tistory.com/96?category=793310)**
## Liveness
* Deadlocks and Starvation
    * 두 프로세스가 서로 종료 될 때가지 대기하는 프로그램을 생각해보자 .프로세스 A는 B가 종료될 때까지, 프로세스 B는 A가 종료될 때까지 작업 하지 않기 때문에 프로그램은 어떤 동작도 하지 못할 것이다. 두 프로세스가 리소스를 점유하고 놓아주지 않거나 . 어떠한 프로세스도 리소스를 점유하지 못하는 상태가 되어 프로그램이 멈추는 현상을 데드락이라고 한다.
* 우선 순위 역전 priority inversion
    * 낮은 우선 순위의 프로세스가 락에 걸린 상태로 실행중 시점일때 높은 우선 순위의 프로세스가 자원을 요구하게 되면 높은 우선 순위의 프로세스는 기다리게된다.
    * 이 문제를 해결하기 위해서 우선 순위 상속 프로토콜이 존재한다. 이 프로토콜에 따르면 더 높은 우선순위 프로세스가 필요로 하는 자원에 접근하는 모든 프로세스는 문제가 된 자원의 사용이 끝날때까지 더 높은 우선 순위를 상속 받는다.
* 고전적인 동기화 문제
    1. 유한 버퍼 문제 : 생산자와 소비자 관계에서 볼 수 있음(서버와 클라이언트 관계)
    2. Readers-Writers 문제 : read 와 write를 동시에 데이터 베이스에서 사용 하게되면 충돌이 날 수 있는 문제를 해결하기 위해서 하나의 부분을 먼저 실행하고 그부분이 끝나면 write를 하는 방식으로 진행한다.
    3. 식사하는 철학자들 문제
# 8장 교착 상태 (DeadLock)
* 대기중인 스레드 또는 프로세스 간에 대기중인 스레드 , 프로세스들이 요청한 자원들이 다른 스레드들에 의해서 점유되어 있고 그들도 다 대기 상태에 결코 다시는 그상태를 변경 시킬수 없으면 이런 상황을 교착 상태라고 한다.
* 교착 상태 특성
    * 필요 조건들
    1. 상호 배제: 최소한 하나의 자원이 비공유 모드로 점유되어야 한다. 비공유 모드애소는 한 번애 한 스레드만이 그자원을 사용 할 수 있다. 다른 스레드가 그자월을 요청하면 요청 스레드 만이 자원이 방출 될때까지 반드시 지연 된어야한다.
    2. 점유되어 대기 : 스레드는 최소한 하나의 자원을 점유한채 현재 다른 스레드에 의해 점유된 자원을 추가로 얻기 위해 반드시 대기해야한다.
    3. 비선점 : 자원들을 선점할 수 없어야 한다. 즉 자원이 강제적으로 방출될 수 없고 , 점유하고 있는 스레드가 태스크를 종료한 후 그 스레드에 자발적으로 방출될 수 있어야한다.
    4. 순화대기 : 대기하고 있는 스레드의 집합에서 하나는 자원을 대기하고 또하나느 사용하고 이와 같은 사이클이 반복적으로 순회 한다.
* 자원 할당 그래프     
* 교착 상태를 가시화 할 수 있는 좋은 방법은 자원 할당 그래프이며 작업 , 자원 , 요청 으로 구성된 그래프를 만들어 사이클이 있는지 검사하면 됩니다.     
* 필요 조건에서 있었던 순환대기다 그래프에 나타났는지 확인하는것이 주 목적이다.
	* 각 자원의 개수가 1개인 경우 :     
		* 사이클이 없다면 : 교착 상태가 없다.
		* 사이클이 있다면 : 교착 상태가 있다.
	* 각 자원의 개수가 1개 이상 경우 : 
		* 사이클이 없다면 : 교착 상태도 없다.
		* 사이클이 있다면 : 교착 상태가 있을 수도 있지만 없을 수도 있다.
* 교착 상태 처리 방법    
    * 문제를 무시하고 교착 상태가 시스템에서 절대 발생 하지않느 척한다.
    * 시스템 결코 교착 상태가 된 않도록 보장하기 위하여 교착 상태를 예방하거나 회피하는 프로토콜을 사용한다.
    * 시스템이 교착 상태가 되도록 허용한 다음에 복구시키는 방법이다
1. 교착 상태 예방 : 원천적인 문제를 봉쇄하여 교착 상태를 해결하는 방법(DeadLock이 발생하는 4가지 조건을 배제하여 교착 상태를 해결하는 방법)
    * 상호배제 :  하나의 자원을 공유가 불가능한 자원이 되도록 만든다. 만약 공유 가능한 자원 가지고 있다면 동시 접근이 가능하며 교착 상태를 야기한다. 이와 같은 문제를 해결하기 위해서 자원 공유를 막는다.
    * 점유하며 대기 : 스레드가 자원을 요청 할때마다 다른 자원을 보유하지 않도록 보장해야 한다.    
    모든 자원을 요청하고 할당 해야 한다.  >> 스레드가 자원을 전혀 갖고 있지 않을때만 자원을 요청 할 수 있다. 
    * 비선점 : 이 조건은 이미 할당된 자원이 선전되지 않아야 한다. 자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고 있는 자원을 반납하고, 요구한 자원을 사용하기 위해 기다리게 한다.
    * 순환대기 : 모든 자원 유형에 전체적인 순서를 부여하여 각 프로세스가 열겨된 순서대로 오름 차순으로 자원을 요청하도록 요구하는 것이다.
2. 교착 상태 회피     
    교착 상태의 알고리즘    
    * 안전 상태 : 시스템 상태가 안전하다는 말은 시스템이 어떤 순서로든 스레드 , 프로세스들이 요청하는 모든 자원을 교착상태를 야기시키지않고 차례로 모두 할당해 줄 수 있다는 것이다.     
        즉 자원 요청이 들어오면 자원을 할당했다고 가정    
        시스템인 안전 상태인지 검사     
        if(안전 상태) 자원을 할당      
        else  자원을 할당하지 않고 대기(안전 상태 될때까지)
        * 자원 할당 알고리즘을 사용하여 안전 상태를 확인 할 수 있고 예약 간선을 통해 미리 생성될 프로세스 , 스레드를 생성하여 여러 가정을 통해 안전성 검사를 하게 되고 사이클 발견유무에 따라 교착상태를 판별하게 된다.
    * 은행원 알고리즘 : 자원 할당 그래프 알고리즘은 종류마다 자원이 여러개씩 있게되면 사용할 수 없는데 이부분을 해결하기 위해서 은행원 알고리즘을 사용하게 된다.    
        일정한 순서에 의해 모든 고객의 요청을 다 들어줄 수 있게 되기 때문이며 자원의 최대 개수를 자원 종류마다 미리 신고해야한다.     
        스레드가 자원들을 요청하면 시스템은 그것을 들어주었을때 시스템이 계속 안전 상태를 유지하고 있는지 검사가 필요하다.
        * 은행원 알고리즘을 구현하기위해서 여러 자료구조가 필요하다.
            1. Available : 각 종류별로 가용한 자원의 개수를 나타내는 벡터
            2. Max : 각 스레드가 최대로 필요로 하는 자원의 개수를 나타내는 행렬 
            3. Allocation : 각 스레드가 현재 할당된 자원의 개수를 나타내는 행렬
            4. Need : 각 스레드가 향후 요청할 수 있는 자원의 게수를 나타내는 행렬
3. 교착 싱태 탐지 : 교착 상태 예방이나 교착 상태 방지 알고리즘이 존재 하지 않을때 필수적으로 존재해야한다.
    * 각 자원 유형이 한개씩 있는 경우 : 대기 그래프라고하는 것을 사용하며 자원 할당 그래프로부터 자원 유형의 노드르 제거하고 적절한 간선들을 결합함으로써 대기 그래프를 얻을 수 있다.
    * 각 유형의 자원을 여러개 가진 경우 : 대기 그래프는 종류마다 자원이 여러개씩 존재하는 상황에서는 사용할 수 없다.
        1. Available : 각 종류의 자원이 현재 몇개가 가용한지를 나타내는 벡터
        2. Allocation : 각 스레드에 현재 할당된 자원의 개수를 나타내는 행렬
        3. Request : 각 스레드가 현재 요청 중인 자원의 개수를 나타내는 행렬
    * 탐지 알고리즘 사용 
        1. 교착 상태가 얼마나 자주 일어나는가?
        2. 교착 상태가 일어나면 통상 몇개의 스레드가 거기에 연루 되는가?
4. 교착 상태로부터 회복 :  교착 상태 발생시 대기 중인 프로세스 및 하나를 중단 하거나 교착 상태의 프로세스에 지정된 자원을 선점하여 교착 상태에서 복구를 시도할 수 있다.
* 프로세스 와 스레드의 종료 : 교착 상태의 프로세스르 모두 중지한다. 교착 상태가 제거 될 때까지 한 프로세스씩 중지한다.
* 자원 선점 
    * 희생자 선택 : 최소 비용을 위주로 선택한다. 
    * 후퇴 
        * Total rollback : 프로세스가 했던 일을 다 취고하고 , 다시 처음 부터 시작
        * Partial rollback : 프로세스가 내놓아야 할 자원을 갖고 핶던 처음 행위(safe state) 까지 취소
    * 기아 상태 
## 9장 메인 메모리 
* 