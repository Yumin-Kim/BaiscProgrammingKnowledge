<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>React</title>
</head>

<body>

    <h1><a href="/">React MEMO</a></h1>
    <ul>
        <li>
            <a href="/react/Webpack">Webpack 정리</a>
        </li>
        <li>
            <a href="/react/Redux">Redux 정리</a>
        </li>
    </ul>
    <div>
        <h2>React 공부 1일차</h2>
        <p>
            <ul>
                <li>닫는 태그가 없으면 / 무조건 사용 해주어야 한다</li>
                <li>onChange를 활용하여 좀더 value 값에 대한 관리를 정확히 할 수 있다 </li>
                <li> Component를 복사 해도 state가 각기 동작 하는것 필히 알것 </li>
                <li>DOM Event 간략하게 보기</li>
                <li>React 사용시 여러 태그를 사용하는데 그 태그들을 감싸주는 태그를 div를 많이 쓰지만 React.Fragment를 사용하여 불필요한 div 태그 삭제</li>
            </ul>
        </p>
        <h2>React 공부 2일차</h2>
        <p>
            <ul>
                <li>REF 는 focus할때 자주 이용 >> 조금더 공부 할 필요 있음</li>
                <li>조금씩 이숙해 져서 혼자 코딩후 영상보기</li>
                <li> Hooks를 활용하여 코딩</li>
                <li>Webpack 활용하여 babel를 사용한 es6 최신 자바스크립트 사용할 수 있고 Browser 지원 또한 가능 </li>
                <li>꼴랑 3시간 밖에 못해서 공부량 부족</li>
                <li>블로그 만들 수 있을까?? 할게 너어어어무 많은거 같다~</li>
            </ul>
        </p>
        <h2>React 공부 3일차</h2>
        <b>Ref 이해 필요</b>
        <textarea name="" id="" cols="30" rows="10">
            //////class 
                사용하고자 하는부분에 this.inputRef.focus(); 사용
                inputRef;
                oninputRef = (e) =>{this.inputRef = c; }
                input type="text" ref = { this.oninputRef } />
            //////Hooks
                import { useRef } from 'react';
                const onRefInput = useRef(null);

                onRefInput.current.focus();
                
                input ...ref={onRefInput} />    
        </textarea>
        <p>
            <ul>
                <li> const () = require('') >> import () from '' ///module.exports = () >> export default = () </li>
                <li> React return 할떄는 최대한 js코드가 안섞긱게 프로그래밍 하기 반복문 사용시 map을 사용하는데 무조건 key적어주기 </li>
                <li>Component 분리 시 해당하는 부분에 state를 props에 할당하여 Component로 전달 해준다 </li>
                <li>Hooks 와 Class 차이를 확실히 이해 해야한다 </li>
                <li>input 사용시 >> onChange 및 value 사용해서 text를 적을수 있다 </li>
                <li>React에서 state와 props가 있는데 props는 직접적으로 바꾸지는 못하는데 state에 props를 넣어서 바꾸는것은 가능하다 </li>
                <li>이유 >> 자식의 props를 바꿔 버리면 부모 또한 바뀌게 된다 </li>
            </ul>
        </p>
    </div>
    <div>
        <h2>React >> 웹 최적화 팁 </h2>
        <h3>항상 최적화에 집중!!</h3>
        <p>밑에 있는 내용은 자식컴포넌트에 적용시 부모한데 사용함을 알고 있어야 한다 </p>
        <li>class >> React.PureComponent 를 사용하여 상태 변경될때만 랜더링 되게 알려줌 </li>
        <li> Hooks >> React.memo를 활용하여 PureComponent같은 역할을 Hooks 에서 될수 있게끔 만들어 준다 </li>
    </div>
    <div>
        <h2> React 공부 4일차 </h2>
        <ul>
            <li>
                Hooks에서 Ref 이용방식이 조금 달라진다
            </li>
            <li>
                <b>Ref와 State가 혼돈 할 수 있는데 State는 상태즉 데이터 변화에 따라 render이 발생하는데 ref는 변화 해도 render이 일어나지 않는다 </b>
            </li>
            <li>
                <b> Ref를 사용할떄 const inputbox = useRef('원하는 숫자나 값을 입력한다(초기값)'); >> 사용할떄는 변수명(inputbox).current = 원하는 값을
                    적는다</b>
            </li>
            <li>
                <p>
                    리액트 라이프 사이클 꼭 인지 하기///최적화에 꼭 중요함!!
                </p>

                <p>
                    class 형식과Hooks 방식 둘다 암기 혹은 익숙해지기
                </p>
                <li>
                    Hooks를 예를 들면 useCallBack , useEffect , useMemo가있는데
                </li>
                <li>
                    <p>
                        <b>useCallBack</b>은 메모리 자체 저장하여
                    </p>
                    <p>
                        <b>useNemo</b>는 함수나 return 안에 있는 값을 기억하고 있고 두번째 인자가 변화 했을때 다시 값을 재 해석할수 있게 한다
                        <p>useMemo(()=>{ return },[변화는 변수])</p>
                        <b>useCallBack</b>는 useMemo 값을 기억하는데 useCallBack 함수 자체를 기억하고 있음   
                    </p>
                </li>
            </li>
            <li>
<h1>React 다시 시작!!</h1>
                <pre>
                    <code>
// PureComponent는 단순한 state 변화는 스스로 shouldCompomentUpdate를 해줌(객체 배열의 state 변화는 못알아본다) 
//state를 객체를 활용하면 계속 새로운 객체를 만들기 때문에 사용 안하는 것이 편함 // 배열은  ...를 사용하면 편함
//[{},{},{}]>>  state이렇게 주는것보다 Componenet를 잘게 만들어서 관리
//sholdComponenetUpdate state,props변화에도 redering 안되게 막을 수 있다!! 
// //랜더링하고 모든 이벤트가 자동으로 실행되는거 같다
// //Ref ,onClick 말고 태그를 이벤트 발생하는 방법 더 생각해보기
// cons = ()=>{
//     // 콜백함수여서 ()=> 없이 넣으면 자동으로 실행
//     console.log('asd')
//     this.setState({result : []});
// }
// makeTag = ( params ) =>{
//    console.log(params)
//    params !== null ? params.addEventListener('click',()=> this.setState({result : []})) : null;
// }

//컴포넌트 라이플 사이클 
// class > constructor > render > ref > componentDidMount > (setState,props > shouldComponentUpdate(true) > render > componentDidMount ) >>(Delete Component)>> componentWilunmount 


///////////////////////
Hooks// 변수를 위로 뺀 이유는 함수 전체가 렌더링 되면서 변수가 undefineed가 된다
//함수 컴포넌트는 전체가 실행되어서 변수를 위에 선언하는 방법도 있지만
//useRef를 활용하는 방법도 있다 >> 활용하여 잠시 기억하는 용으로 사용 가능!!
//값이 바뀌어도 render에는 영향을 미치고 싶지 않을때 사용!! >> current 사용 주시!!

//useEffect가 처음에는 실행되고 그다음 useEffect가 실행되는 여부는 [안에 변하는 state값을 넣어 주면 그값이 변할때 마다 실행된다]
//
// useEffect(() => {//componentDidMount , componentDidUpdate
//     console.log("componentDidMount , componentDidUpdate",++counter)
//     intervalRSP();
//     return () => { // componentWillmount
//         console.log("componentWillmount")
//         clearInterval(interval.current);
//     };
// }, [imgCoord])//[ 배열안에 변화하는 state를 매개변수로 넣게 되면 그 state가 변화 할때마다 componentDidUpdate 실행// 꼭 state가 아니여도 괜찮음 ]
//무거운 함수면 useMemo 함수값 기억!!
//함수 자체를 기억 또한 값또한 변화가 없으면 계속기억
                    </code>
                </pre>
            </li>
            <li>
                
            </li>
        </ul>
    </div>
</body>

</html>