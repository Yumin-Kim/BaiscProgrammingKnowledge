# Computer
동작 원리 파악 후에 세부적인 내용 정리
* CPU 동작 원리 >> 쉭게 설명하면 기억을 꺼내서 연산후 기억을 넣음
    * 동작 원리 파악 하기전에 구성 요소
        * 연산 장치 : 산술 연산 및 논리 연산 수행 두가지 모든 연산을 수행하기 때문에 산술논리 연산이라고 한다    
          연산에 필요한 데이터를 레지스터에서 가지고온다 그후 연산 결과는 다시 레지스터로 보내 저장한다
        * 제어 장치 : 명령어를 순서대로 실행 할 수 있도록 제어 할 수 있는 장치이다    
            주기억 장치에서 프로그램 명령어를 꺼내어 해독한 다음  해독한 결과에 따라 명령어 실행에 필요한 제오 신호를 기억 장치 , 연산 장치 , 입출력 장치로 보낸다(보낸후에 다음에 수행할 동작을 결정한다)
        * 레지스터 : 고속 기억 장치로 명령어 주소 , 명령어 코드 ,연산에 필요한 데이터 ,연산 결과를 임시 저장한다(용도에 따라 범용 특수목적으로 구분된다)
            * 범용 레지스터 : 연산에 필요한 데이터나 연산 결과를 임시로 저장
            * 특수 레지스터 : 말그대로 특별한 용도로 사용되는 레지스터를 용도에 기능        
                * 메모리 주소 레지스터(MAR) : 읽기 와 쓰기 연산을 수행할 주기억장치의 주소를 저장
                * 프로그램 카운터(PC) : 다음에 수행할 명령어의 주소를 저장
                * 명령어 레지스터(IR) : 현재 실행중인 명령어를 저장
                * 메모리 버퍼 레지스터(MBR) : 주기억장치에서 읽어온 데이터나 주기억 장치에 데이터 임시 저장
                * 누산기(AC) : 연산 결과를 임시로 저장
    * CPU 동작 과정
        1. 주기억 장치는 입력장치에서 입력 받은 데이터 또는 보조기억 장치에 자장된 프로그램을 읽어온다
        2. 중앙 처리 장치는 프로그램을 실행하기 위해서 저장된 프로그램 명령어와 데이터를 읽어와 처리하고 결과르 다시 주기억 장치에 저장
        3. 주기억 장치는 처리 결과를 보조기억 장치에 저장하거나 출력 장치로 내보냅니다.
        4. 제어 장티은 1~3 과정에서 명령어가 순서대로 실행될수 있도록 각 장치 제어
    * 정의 
        * Unit   
        한개의 구성여소를 유닛이라고 부른다!!
        * 프로세서
            기본적으로 명령어들을 처리하는 논리 회로
            * 프로세서의 구성 요소
                * CPU : 디바이스가 해야할 일을 총 지휘하는 프로세서(중앙 처리 장치로 Processor중의 하나라고 보면됨)
                    * Core : 프로세서의 핵심 연산 장치 (코어가 많을수록 병렬 처리 효율이 늘어남 Core는 종류에 따라 ARM계열 ,MIPS계열 , x86계열 등의 ISA(Instruction Set Architecture))으로 구분한다
                        1. 제어 장치(Control Unit) : 소프트웨어를 읽고 하드웨어의 다른 부분으로 신호를 보냄
                        2. 연산장치(Arithmetic Logic Unit) : 사칙 연산과 AND , OR와 같은 논리 연산등을 담당
                        3. 레지스터
                    * JTAG , 내부 버스 , 캐시(Cache) 
                * 보조 프로세서(Coprocessor) : CPU의 기능을 보조하는 프로세서
                * 마이크로프로세서(Micro Processor) : PC나 소형 디바이스에 장착된 프로세서
                * MPU(Micro Processor Unit) - 라즈베리 파이 (연산이 필요할때(기본적으로 OS가 올라가있음))
                    * MCU와 달리 MPU는 컴퓨터의 핵심 기능인 주어진 기계어 해석 , 연산을 수행하는 기능만 가지고 있는 프로세서
                    * MPU는 주변에는 RAM , ROM I/O 등의 장치를 추가해주지 않으면 작동을 하는것이 불가능하다
                * Micro Processor   
                    마이크로 프로세서는 CPU(컴퓨터 중앙 처리 장치(Central Process Unit))의 핵심 기능을 통합한 집적 회로(IC[거미 같이 생긴 칩])이다  
                    CPU중에서도 각종 전자부품과 반도체 칩을 하나의 작은 칩에 내장한 형태를 마이크로 프로세서라고한다 
                    바이너리 데이터의 입력을 받아들이고 메모리에 저장된 지침에 따라 처리한 후 출력을 제공한다
                * MCU(Micro Control Unit) - 아두이노(연산이 아닌 제어만을 목적으로 할때 사용 OS가 올라가 있지 않음)
                    * MCU는 CPU의 기능을 하는 핵심 잧이 와 그 주면 장치들을 포함하고 있는 통합형 침셋
* RAM 과 Register 차이    

* Register 와 Cache Memory     
캐시(보조 구성요소) :  CPU칩안에 내장되어 있고 프록그램에서 직접적으로 읽거나 쑬 수 없거고 하드웨어의 메보리 관리 시스템이 내부적으로 제어 한다      
RAM에 있는 데이터를 캐시메모리에 불러와 두고 CPU가 필요한 데이터를 케시에서 먼저 찾도록 하면 시스템 성능향상    
cpu와 내부에 설치되기 하지만 cpu와 캐시의 회로는 독립적으로 형성하고 있다            
Register(CPU의 필수 구성 요소) : CPU에 존재하는 다목적 저장 공간이며 데이터와 명령어를 저장하는 역할을 한다     
Flip Flop의 집합이며, 이 Flip Flop이라는 것은 각각 1bit의 정보를 저장할 수 있는 것들을 의미.    
일반젇으로 현재 계산을 저장하는데 사용     
컴퓨터는 캐시로 부터 데이터를 읽어들여 레지스터에 저장한 다음 레지스터 사이로 데이터를 전달하면서 연산(데이터를 처리하가위해서 받아오는것이며 저장하기위해서 들어오는것이 아니다)     
<strong>캐시 , 레지스터의 공통점은 어떤 명령어나 데이터를 저장해두는 공간</strong>   
<strong>캐시CPU와 별도로 있는 공간이며 메인 메모리와 CPU간의 속도 차이를 극복하기 위한것 </strong>   
<strong>레지스터는 CPU안에서 연산을 처리하기 위하여 데이터를 저장하는 공간</strong>    
속도면에서는 Register > Cache > Memory > Disk

# C언어 기본원리 파악하기!!

* 변수의 정의
    * 변수는 기본적으로 메모리의 주소를 기억하는 역할을 한다
    * 메모리 주소는 물리적인 메모리 공간을 서로 구분하기 위해 사용되는 일종의 식별자 이다
    * 즉 메모리 주소란 메모리 공간에서의 정확한 위치를 구분하기 위한 고유 주소를 의미한다
    * 변수를 참조 할때는 메모리의 주소르 참조하는것이 아닌 해당 주소에 저장된 데이터를 참조하는 것이다
    * 따라서 변수는 데이터가 저장되는 메모리의 주소뿐만 아니라 저장된 데이터의 길이와 형태에 관한 정도도 같이 기억해야한다!!      

    * 개발자가 어떤 주소를 사용할 것인지 표현은 할수 있어야 하기 때문에 주소대신 사용하려고 만든 개념이다
    * 사용할 메모리에 대해 단어로 이름을 지어준 것이 변수 입니다.

* 변수에 자료형을 적어주는 이유!!
    * int char long 등등 이런 자료형을 미리 정의하는이유는 메모리 공간을 할당할 수 있는 것이다.
    * 메모리를 할당받는 행위는 변수의 선언이라고 한다!

## 변수의 결론!!!
* 변수의 개념을 논할때는 메모리 주소 와 저장된 데이터의 길이 형태 통틀어서 테이터의 크기를 근거로 설명 할 수 있
* 상수 
    * 상수란 변수와 마찬가지로 데이털를 저장할 수 있는 메모리 공간을 의미한다!!
    * 상수는 한번 지정한 데이터는 변경할 수 없음!! 이 점은 대규모 프로젝트를 하게 될때 빛을 본다!!
    * C++과 같은 언어에는 참조자 연산자를 사용하는데 이점의 유의하고!!

* 메모리 구조 !!
    * 프로그램이 실행되기 전에는 먼저 프로그램의 메모리에 로드 되어야 한다
    * 또한 포로그램에서 사용되는 변수들을 저장하는 메모리도 필요합니다!     

## 중요!! 
* 컴퓨터의 운영체제는 프로그램의 실행을 위해 메모리 공간을 제공하고 있습니다 
* 프로그램이 운영체제로부터 할당 받는 대표적인 메모리 공간은 
    1. 코드영역 >> 실행할 프로그램의 코드
        * 메모리의 코드 영역은 실행할 프로그램의 코드가 저장되는 영역으로 텍스트 영역이라고 한다
        * CPU는 코드 영역의에 저장된 명령어를 하나씩 가져가서 처라하게된다!!
    2. 데이터 영역 >> 전역변수 정적변수
        * 데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸합니다.
    3. 스택 영역 >> 사용자의 동적 할당 
        * 스택 영역은 함수의 호출과 함께 할당되며 함수의 호출이 완료되면 쇼멸한다
        * 스택 영역에 저장되는 함수의 호출 정보를 스택프레임이라고 한다.
    * 중요한 부분 >>>스택 프레임    
        * 함수가 호출되면 스택에는 함수의 매개변수 , 호출이 끝난 뒤 돌아갈 반환 주소값 , 함수에서 선언된 지역 변수등이 저장 됩니다
        * 스택 영역에는 차례대로 저장되는 함수의 호출 정보를 스택 프레임이라고 한다
## 중요!!!
* 이러한 스택 프레임 덕분에 함수의 호출이 모두 꿑난뒤에 , 해당 함수가 호출되는 이전 상태로 되돌아갈 수 있다!!!
* 스택에 쌓이는 순서는 위에서 설명한것과 같이  매개변수 >> 반환 되는 주소값 >> 지역변수
* 스택 영역은 push동작으로 데이터를 저장하고 pop동작으로 데이터를 인출한다!!
* 스택영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다!! 늦게 호출될수록 높은 주소에 해당한다!!

    4. 힙 영역 >> 지역변수와 매개변수
        * 사용자 즉 개발자가 직접 관리할 수 있는 그리고 해야만하는 부분인 메모리 영역입니다!!
        * 힙영역은 개발자로 인해서 메모리 공간을 동적으로 할당되고 해제됩니다!!
        * 메모리의 낮은 주소에서 높은 주소로 할당된다!!
# 함수 
* 하나의 특별한 목적의 작업을 수행 하기 위해서 독립적으로 설계된 프로그램 코드의 집합으로 정의 할 수 있습니다

## 몰랐던 내용 기록!!
컴파일러가 메모리를 분배하는 규칙을 "스택 프레임'
# 임베디드 기초 
* 전자 부품의 이해 (전기를 사용함에 따라 기초적으로 사용하는 공식인 옴의 법칙 V(전압) = IR(전류 * 저항))     
스위치 : 전기적으로 연결되거나 끊어지는 부품   
저항기 : 전기적 에너지를 열로 발산하는 소자(CDS-빛 밝기(예로는 조도센서[아날로그의 정보를 가지고 올 수 있다])) 극성이 없다!!      
축전기 : 전하를 보관하는 소자 (캐퍼시티(금속판과 전해액을 활용하여 배터리 처럼 사용될 수 있다),축전기(휴대폰이나 차량 배터리),가변용량 다이오드)    
인덕터 : 자기력을 사용하는 전기 소자 (가변코일,전기 모터,스피커) - 자석 과 자기력이 결합하여 전기 에너지를 운동 에너지로 변형하여 모터를 사용할 수 있다    
진동자 : 압전효과를 사용하는 수동 소자(피에조 부저,아두이노의 크리스털 진동자(은색 판))-전기를 흘려 주게되면 판이 흔들리면서 소리가 나게 된다 - 아두이노의 은색 바같은데 있는데 금속에 전기를 인가 하게 되어서 일정한 패턴으로 진동을 활용하여 소리가 나게 된다!!   
전원장치 : 전력 공급 소자(AA배터리 연료 전지) 직렬 1.5V 두개는 3V 병렬은 1.5V 이다!!   
반도체 : 전기를 이용해 제어할 수 있는 소자 (다이오드 트랜지스터 레귤러레이터) 다이오드는 전류를 한방향으로 흐르도록 도와 준다!!   
   
IC(Intergrated Circulit)    
수백만개의 저항 , 커패시터 , 트랜지스터드이 하나의 패지지에 들어간 저자 부품

트랜지스터 - 논리 회로 , 증폭기   
이미터(E)B와 C에서 흐르는 전류의 합      
컬렉터(C)B에 전휴가 흐르면 컬렉터에서 흐르는 전휴가 이미터에 더해짐    
베이스(B)트랜지스터르 작동시키는 약한 전기 신호 입력     


## 임베디드의 정의
* PC와의 비교했을때 PC는 범용적으로 사용되며 필요한 작업을 해당 하는 소프트웨어를 통해 원하는 작업을 수행 할 수 있다   
    하지만 임베디드 시스템은 특정한 목표를 가지고 설계되었다. 해당하는 하드웨어의 기능을 적절히 제공하고 하드웨어를 제어 하려는 기능을 제공한다   
    사용자는 간편하게 버튼만을 통해서 서비스를 이용할 수 있다. 범용적인 기능이 아닌 한정된 기능(특수 목적)을 가지고 제작 되기 때문에 시스템을 구성하는 장치나 소프트웨어가 제한적이다   
* 임베디드 시스템 구현은 하드웨어만으로 구현이 가능하며 소프트웨어와 하드웨어를 병행하여 구현 할 수 있다    
    하드웨어로만 구현 되었을때 빠른 속도로 개발 할 수 있지만 수정이나 확장하기가 어렵다 그래서 일반적으로 하드웨어와 소프트웨어를 병행하는 경우가 많다!!   
    병행함에 있어 소프웨어을 동작 속도를 높히기 위해서 성능이 좋은 프로세서를 사용하는 경우가 있다    
    임베디드와 PC에서 사용되는 프로세서는 확연히 다르며 대표적으로 사용되는 프로세서는 ARM , MiPS등등이 있다   
    임베디드 프로세서는 다양하지만 공통으로 고려해야 하는 사항이 있다. 가격 , 전력 소모 , 성능 ,  크기를 신경 써야 한다.
* 임베디드 소프트웨어 개발 방법    
    PC와 비교한다면 PC에서 직접개발 하게 되면 개발하는 시스템 프로세서와 프로그램이 실행될 시스템의 프로세서가 같다.<strong>이를 네이티브 개발환경이라고 한다.</strong>   
    하지만 임베디드 소프트웨어 개발 환경은 개발하는 시스템의 프로세서와 실행될 시스템의 프로세서가 같지 않으면 이를 크로스 개발 환경이라고 한다.   
    개발 환경의 프로세서를 위한 프로그램을 개발하는 위한 프로그램을 개발하는 것이 아니므로 생성되는 실행 파일을 현 시스템에서 실행시키면 실행할 수 없는 파일이라는 오류가 발생한다    
    생성된 바이너리 코드를 현재 프로세서에서는 인식하지 못하기 때문이다. 이 말은 일반 응용 프로그램을 개발할때 사용하는 컴파일러와느 다른 컴파일러가 사용된다는 것을 알 수 있다.    
    즉 임베디드 소프트웨어를 개발하려면 개발환경과 다른 프로세서용 기계코드를 생성해주는 컴파일러가 필요하며 이르 크러스 컴파일러라고 한다. 예를 들어 ARM용 크로스 컴파일러에는 arm-linux-gcc나 ADS등이 있다    
    크로스 개발에서 소프트웨어를 개발하는 환경을 호스트 시스템 , 소프트웨어가 실행되는 시스템을 타겟 시스템이라고 한다.    
    쉽게 말해서 프로그램 개발 작업을 하느 PC가 바로 호스트 시스템이되고 , 임베디드 프로세서와 메모리 및 주변 기기로 이루어진 임베디드 시스템이 바로 타겟 시스템이 된다.    
    일반 소프트웨어를 개발 할때는 컴파일러 , 어셈블러 , 링커 , 등이 필요하듯이 임베디드 소프트웨어를 개발할 때에도 이러한 개발툴이 필요하다.    
    임베디드 시스템은 개발환경과 실행 환경이 같지 않기 때문에  크로스 컴파일러나 크러스 어셈블러를 사용한다는 차이점이 있으며 이를 툴체인이라고한다.   
    툴체인은 크러스 컴파일러, 크로스 어셈블러 , 링커/러케이터등으로 구성된 소프트웨어 개발도구를 말한다. 크로스 컴파일러는 개발환경과 다른 타겟 시스템의 프로세서용 바이너리 코드를 생성한다.    
    <strong>크로스 컴파일러 과정</strong> test.c >> 전처리기 >> test.i >> 크로스 컴파일러 >> test.s >> 크로스 어셉블러 >> test.o >> 링커 >>  로케이터(타겟 시스템의 메모리 정보를 필요로하며 이는 링커 스크립트 파일에 의해서 제공한다) >> test(실행파일)     
    오브젝트 파일을 실행 가능한 바이너리 이미지로 변환 되어야 하는데 그과정이 바로 로케이트이다. 이때 타겟 보드의 메모리 정보를 로케이터에 알려주어야 이 정보를 이용해서 실제 메모리 주소를 할당할 수 있다.   
    로케이트는 프로그램 코드와 데이터 섹션들에 실제 메모리 주소를 할당하는 과정이다.(데이터 섹션이란 실행될때 메모리는 기계어 코드가 들어 있느 코드 섹션과 데이터를 저장하는 데이터 섹션이 으로 나뉜다 데이터 섹션은 다시 3부분으로 나눠어 지며 전역 메모리 스택 메모리 힙메모리가 있다 >> 스택 프레임 !!)    
    타겟 보드의 메모리 정보는 컴파일러의 옵션을 이용하여 설정 할 수 있고 , 스크립트 파일이 사용된다. 링커 스크립트에는 ROM의 시작 주소와 RAM의 시작 주소 각 섹션의 시작과 끝을 나타내는 심볼들로 구성되어 있다(심볼의 의미 힘수의 이름이나 변수의 이름을 의미하고 오브젝트 파일에 같은 이름의 함수 또는 같은 이름의 변수 명이 정의 되어 있을때 어떤 파일의 어떤 함수의 것을 사용해야하는가를 결정하는 일을 의미한다 >> EX) 링커가 두개의 오브젝트 파일을 합쳐서 하나의 수행 파일로 만들때 두개의 함수명 같은 함수를 어떤 함수로 사용할지 결정하는것이다)
* 프로그램을 어떻게 타겟 시스템으로 옮기나    
    호스트에서 개발한 소프트웨어를 타겟 시스템에 전송하려면 케이블이 필요하며 시리얼 케이블 , JTAG 케이블 , 이더넷/ USB 케이블등이 있다.    
    시리얼 케이블은 UART 통신을 위한 케이블이다. UART란 범용 비동기화 송수신기(Universal Asynchonous Receive/Transmitter)로써 직렬 장치를 이용한 통신을 말한다.통신 내용은 시스템 콘솔을 사용해 확인 가능하다. 타겟 시스템의 프로그램이 제대로 작동되는지 모니터링을 할 수 있고 디버깅도 가능하게 한다.    
    다음으로 JTAG 케이블은 타겟 시스템에 프로그램을 다운로드하거나 플래시 메모리에 프로그램을 탑재할 수 있다. 또 레지스터의 값을 읽어 올 수 있거나 프로그램을 스텝으로 작동시키는 등 디버깅이 가능하다    
    이더넷/USB 케이블은 타겟 시스템에 개발한 소프트웨어를 탑재할 수 있다. 하지만 이들을 위한 추가 프로그램이 필요하다.    
* <strong>임베디드 시스템은 특화된 기능을 제공하기 때문에 다양한 리소스를 가지고 있지 않고 그래서 PC에서 임베디드 소프트웨어을 개발 해야하는데 문제점은 타겟 시스템과 호스트 시스템의 프로세서가 일치 하지않는다는것 그래서 툴체인을 호스트 시스템에 구성하여 타겟 시스템에서 작동할 소프트웨어를 개발한다.하지만 개발한 소프트웨어를 타겟 시스템 용이기 때문에 호스트 시스템에서는 컴파일만 가능할 뿐 테스트를 못하는데 이부분은 케이블과 소프트웨어을 통해서 디버깅및 다운로드가 가능하다</strong>     
* 임베디드 소프트웨어의 실행    
    임베디드 시스템메서의 C프로그램이 작동하려면 초기화 작업이 필요하다.이러한 역할을 하는 코드를 스타트업 코드라고 하며 임베디드 시스템에서는 개발자가 직접 만들거나 타겟 시스템의 판매회사에서 제공하기도한다. 스타트업 코드는 인터럽트 백터 데이블을 생성하고 메모리 검사와 C프로그램에서 사용할 스택과 힙을 생성하고 초기화 하는 등 C 프로그램이 작동하기 위한 초기화 작업을 수행한다. 이 작업이 끝나면 마지막으로 C의 main() 함수를 호출하여 프로그램이 시작되도록 한다.(스타트업 코드는 시스템이 C를 인식하기 전의 코드이기 때문에 어셈블리 코드로 생성된다)