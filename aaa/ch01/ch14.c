#include <stdio.h>
/*
변수와 상수 고급 이론
변수의 본질은 메모리이고 상수의 본질은 메모리에 저장되는 정보 그자체를 의미한다(모두 자료형 개념이 있다)
최적화는 컴파일러가 소스 코드를 최적화하는 일을 의미 한다
빌드(컴파일 + 링크)
빌드를 하는과정에서 모드가 있는데 초기에는 Debug >> release 빌드를 하게 되어 있다
Debug에서는 오류가 없는데 Release에서는 오류가 발생하는 경우가 있다
이런 문제를 해결 하기위해서는 컴파일러 최적화에 관련이 있다
최적화의 문제는 연산자의 문제가 있다
*/
//
void Testfunc(int);
int main() {
	/*
	Release 모드로 변경후에 빌드하게 되면 Debug중단점이 22번째 줄로 이동하게 된다!!
	이유는 최적화를 통해 쓸모없는 반복문을 제외하기 때문이다!!(즉 쓸모없는 연산은 하지 않기 때문!!)
	컴파일로가 필요하고 필요하지 않은 연산을 알고 있다!!
	최적화의 의미는 논리적으로 매우 당연한 소스코드는 제외시킨다!!(예 : 반복문안에 변수 선언!!)
	최적화를 하기 위해서는 특정 변수에 대해 의존성이 존재 하는 연산들을 구별할 수 있어야 한다!!
	최적화 하기 위한 최선의 방법은?
	컴파일러가 최적화하기 좋더록 작성하기!!
	최적화는 low + 기계적이기 때문에!!
	최적화의 방해요소는 변수가 많은 경우를 피해야 한다!!
	포인터 사용을 주의 한다!!(포인터 사용을 자제해야한다!!) >> 포인터를 사용하게되면 컴파일러 분석에는 좋지 않다!! 컴파일 당시의 에러 보다는 Runtime에서 에러가 발생하기 때문에 찾기 힘들다!!
	C++에서는 상수화된 포인터를 사용하게 된다(참조!!)
	
	const 
	어떤 메모리를 읽기 전용 메모리로 만들어 주는 기능을 제공한다!!
	const는 하드 코딩을 최소화 할때 사용되며 이렇게 사용 하는것을 심볼릭상수(Symbolic constant)라고 한다

	상수형 포인터
	최적화 방해요소를 제거하기 위해 포인터 사용 주의를 하는데
	const를 어디에 쓰는지에 따라 달라지는데 자료형 앞에 쓰게된다면 자료형을 상수화 시키고
	변수면에 const를 사용하게 된다면 또다른 주소로 바뀌는것을 막아준다!!
	이 모든 에러는 Runtime이 아니라 컴파일러에서 오류가 발생하기때문에 그이상의 버그를 못만들게 막아준다!!
	예시))	const int* pnData = &nData;
			int* const pnData = &nData;
	volatile 
	const와 다르게 정반대의 역할을 한다(변수와 관련된 모든 연산에 대해 컴파일러가 최적화규칙을 적용하지않는다)

	extern

	*/

	Testfunc(10);

	int nData = 0, nResult = 10;
	char nName[12] = { "Hello" };
	char szBuffer[32] = { "I am a boy" };
	const char* pszBuffer = szBuffer;
	szBuffer[0] = 'i';
	//자료형 앞에 쓰게 되면 포인터가 가리키는 대상은 간접 지정은 할 수 있지만 l-value로는 사용하지 못한다 
	//*pszBuffer = 'i';

	for (int i = 0; i < 10; i++)
		nData = 10;
	printf("nData = : %d\n", nData);
	printf("HEllo");
	return 0;
}









